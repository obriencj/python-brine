# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, see
# <http://www.gnu.org/licenses/>.


"""

Messing with Python Function, Code, and Cell objects

This is a code narrative that explains how functions are represented,
and what information we need to have to assemble new functions.

author: Christopher O'Brien  <siege@preoccupied.net>
license: LGPL v.3

"""


import new


# a simple function that adds the constant 8 to its argument and
# returns the result
def add_8(x):
    return x + 8

# let's try it out
print "add_8(100) is", add_8(100)



def code_unnew(code):

    ''' returns the necessary arguments for use in new.code to create
    an equivalent but separate code block ''' 
    
    return [ code.co_argcount,
             code.co_nlocals,
             code.co_stacksize,
             code.co_flags,
             code.co_code,
             code.co_consts,
             code.co_names,
             code.co_varnames,
             code.co_filename,
             code.co_name,
             code.co_firstlineno,
             code.co_lnotab ]



#
# now let's see if we can't make a function to instead add 5. But
# instead of rewriting it, let's just make it use the same guts as
# add_8, only with a different constant


code = add_8.func_code
uncode = code_unnew(code)

# change constants
uncode[5] = (None, 5)

# build a new code block from our modifications
new_code = new.code(*uncode)

# create add_5 from the new code block
add_5 = new.function(new_code, globals(), None, None, ())

# let's try out the new function
print "add_5(100) is", add_5(100)



#
# Python's Cell type isn't very exposed. In fact, you can't even get
# its type from the types module! So we have to use some trickery to
# allow us to get that type (CellType), to get the value wrapped in a
# cell (cell_get_value), and to create a new cell wrapping a given
# value (cell_from_value).


# this simple function will return a function that has x in its
# closure and that, when called, returns the value of x
def dummy_id(x):
    return lambda: x


# we won't be using this type object directly, but this is just in
# case you wanted to see how to quickly get it
CellType = type(dummy_id(0).func_closure[0])


# this function will create a new function using the code from a
# function generated by dummy_id, but with our own cell in place of
# its own. It then calls the new function, which returns the value
# inside the cell
def cell_get_value(cell):
    dummy = dummy_id(0)
    reveal = new.function(dummy.func_code, globals(),
                          "<reveal>", None, (cell,))
    return reveal()


# this function will create a new function using dummy_id and our
# value, then steal the cell from the function's closure
def cell_from_value(val):
    dummy = dummy_id(val)
    return dummy.func_closure[0]



#
# Well that was fun, but what happens if the value we want to replace
# isn't in the constants pool for the code, but is instead a closure
# on the function? Consider the following function that generates an
# adder, and a +9 adder that it can generate

def make_adder(by_value=1):
    def adder(x):
        return x + by_value
    return adder

add_9 = make_adder(9)

# let's try it out
print "add_9(5) is", add_9(5)


#
# Let's see if we can't make an add_7 out of add_9

code = add_9.func_code

# here's the cell with our stored value
cell = add_9.func_closure[0]

# let's see what the value of that cell is (it ought to be a 9)
print "value in cell from add_9 is", cell_get_value(cell)

# let's make a replacement cell containing a 7, instead
new_cell = cell_from_value(7)

# now let's roll a new function using the new cell
add_7 = new.function(code, globals(), None, None, (new_cell,))

# and let's try it out
print "add_7(5) is", add_7(5)



# So far we haven't been updating the internal names of either the
# code block or the function definitions. If you were to ask add_7
# what its name was, right now it would tell you, "adder" rather than
# "add_7"

print "add_7.func_name is %r" % add_7.func_name
print "add_7.func_code.co_name is %r" % add_7.func_code.co_name

# this is because that's how the code was originally defined (see
# make_adder, above), and when we built add_7 from pieces, we
# neglected to specify any other name.


# TODO: rename add_7


# TODO: explain pickling


# TODO: explain what happens when you pickle a Function


# TODO: explain brine


# TODO: explain recursive functions


# TODO: explain recursive anonymous functions


# TODO: explain barrel


# TODO: explain cellwork


#
# The end.
